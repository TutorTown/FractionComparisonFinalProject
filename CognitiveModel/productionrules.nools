// import("types.nools");
function canCompare(n1, d1, n2, d2) {
	if (n1 === n2 || d1 === d2 || (n1/d1 < 1 && n2/d2 > 1) || (n1/d1 > 1 && n2/d2 < 1)) {
		return true;
	} else {
		return false;
	}
}

rule bootstrap {
	when {
		b: Boolean b === true from true;
	}
	then {


			// Fill in fractions for comparision
			assert(new TPA("num1", "UpdateTextArea", num1));
			assert(new TPA("den1", "UpdateTextArea", den1));
			assert(new TPA("num2", "UpdateTextArea", num2));
			assert(new TPA("den2", "UpdateTextArea", den2));


			// Create Problem
			assert(new Problem(num1, den1, num2, den2));

			setProblemAttribute("use_backtracking", true);
			halt();		

	}
}

rule loadSkills {
	when {
			p: Problem p.goal === "loadSkills";
	}
	then {


			if (checkSAI({selection: "don't_care", action: "don't_care", input: "don't_care"})) {
				let skills = CTAT.ToolTutor.tutor.getProblemSummary().getSkills().getAllSkills();
				console.log("\n\nskills");
				console.log(skills);
				let s1_skill = 0;
               if(p.den1 == p.den2)
               {
               		console.log("Got skill: same den");
                	s1_skill = skills[0].getPKnown();
                	console.log(skills[0].getSkillName());
               }
               else if(p.num1 == p.num2)
               {
               		console.log("Got skill: same num");
                 	s1_skill = skills[1].getPKnown();
                 	console.log(skills[1].getSkillName());
               }
               else if( (p.num1/p.den1 < 1 && p.num2/p.den2 > 1) || (p.num1/p.den1 > 1 && p.num2/p.den2 < 1))
               {
               		console.log("Got skill: compare to 1");
                    s1_skill = skills[3].getPKnown();
                    console.log(skills[3].getSkillName());
               }
				else 
				{
					console.log("Got skill: unlike");
                    s1_skill = skills[2].getPKnown();
                    console.log(skills[2].getSkillName());
				}
				if (s1_skill < 0.25)
				{

					console.log("Worked example");
	                assert(new TPA("step_1_worked", "SetVisible", true));
	                assert(new TPA("step_1_reason_container", "SetVisible", true));
					// Reveal step 1 worked example version
					let workedExampleText = "";
					if (canCompare(num1, den1, num2, den2)) {
						workedExampleText = "We can compare these two fractions without writing them differently. Do you know why?";
					} else {
						workedExampleText = "We can't compare these two fractions without making some changes first. Do you know why?";
					}
					console.log(workedExampleText);
					modify(p, "step1Version", "worked");
					assert(new TPA("step_1_worked", "UpdateTextField", workedExampleText));


				}
				else
				{
					console.log("practicing step 1");
                 	assert(new TPA("step_1_practice_container", "SetVisible", true));
                 	modify(p, "step1Version", "practice");

				}

				modify(p, "goal", "step1");
				halt();
			}

	}
}

////////////////////////
// Step 1 Explanation //
////////////////////////
rule step1ReasonSameNum {
	when {
		p: Problem p.goal === "step1" && p.num1 == p.num2 && p.step1Version == "worked";
	}
	then {
		if (checkSAI({selection: "step_1_reason", action: "UpdateRadioButton", input: "step_1_reason\n-option-0: The numerators are the same."})) {
			modify(p, "goal", "step5");
			assert(new TPA("step_5_practice", "SetVisible", true));
			halt();
		} else {
			backtrack();
		}
	}
}

rule step1ReasonSameDen {
	when {
		p: Problem p.goal === "step1" && p.den1 == p.den2 && p.step1Version == "worked";
	}
	then {
		if (checkSAI({selection: "step_1_reason", action: "UpdateRadioButton", input: "step_1_reason\n-option-1: The denominators are the same."})) {
			modify(p, "goal", "step5");
			assert(new TPA("step_5_practice", "SetVisible", true));
			halt();
		} else {
			backtrack();
		}
	}
}

rule step1ReasonCompareToOne {
	when {
		p: Problem p.goal === "step1" && ( (p.num1/p.den1 < 1 && p.num2/p.den2 > 1) || (p.num1/p.den1 > 1 && p.num2/p.den2 < 1) ) && p.step1Version == "worked";
	}
	then {
		if (checkSAI({selection: "step_1_reason", action: "UpdateRadioButton", input: "step_1_reason\n-option-2: One of the fractions is less than 1 and the other is greater than 1."})) {
			modify(p, "goal", "step5");
			assert(new TPA("step_5_practice", "SetVisible", true));
			halt();
		} else {
			backtrack();
		}
	}
}

rule step1ReasonUnlikeFractions {
	when {
		p: Problem p.goal === "step1" && !canCompare(p.num1, p.den1, p.num2, p.den2) && p.step1Version == "worked";
	}
	then {
		if (checkSAI({selection: "step_1_reason", action: "UpdateRadioButton", input: "step_1_reason\n-option-3: None of the above"})) {
			modify(p, "goal", "step2");
			halt();
		} else {
			backtrack();
		}
	}
}


rule step1practice
{
	when 
	{
      p : Problem p.goal === "step1" && p.step1Version == "practice";
	}
	then
	{
		const compare = canCompare(p.num1, p.den1, p.num2, p.den2);
		console.log(compare);
		if (compare) {
			if (checkSAI({selection: "step_1_practice", action: "UpdateRadioButton", input: "step_1_practice-option-0: Yes"})) {
				modify(p, "goal", "step5");
				halt();
			} else {
				backtrack();
			}
		} else {
			if (checkSAI({selection: "step_1_practice", action: "UpdateRadioButton", input: "step_1_practice-option-1: No"})) {
				modify(p, "goal", "step2");
				halt();
			} else {
				backtrack();
			}
		}
	}
}

////////////////////////
// Step 2 Explanation //
////////////////////////
